
# `km` analysis with SAHMRI ALL targets

Jimmy Breen : jimmy.breen@sahrmi.com
Jacqueline Rehn : jacqueline.rehn@sahmri.com

Utilises k-mer variant detection software 'km' developed by a canadian bioinformatic group (https://github.com/iric-soft/km) and input targets designed for all gene fusions/variants

## Install jellyfish and km

1. To install and run the km script we'll need to create a conda environment to install km and jellyfish in. Jellyfish needs additional python bindings to work with km, so we have created an install procedure to follow.

```
conda create -n km python=3.7 virtualenv -y
conda activate km
```

2. Next we will clone the git repository containing the targets generated for detecting ALL specific fusions/variants as well as bash scripts to install and run km against these targets. 
```
git clone https://github.com/sagc-bioinformatics/km_ALL_targets.git
```

3. Now we can install the km/jellyfish components using this `install.sh` script. First we change into the km_ALL_targets directory generated by git, or an alternate directory for the git-repository if one was spcified. We then run the install script which will install km and jellyfish into this directory. The install script will also perform a test of km using test count-data and targets provided by the developers of km. Output from this test will be written to stout. Note the install script requires `curl` be installed on your machine. 

```
cd km_ALL_targets
bash install.sh
```

## Quick Start

We now wish to test km against a single RNA-seq sample utilising the ALL_targets. 

ALL_targets have been subdivided according to the main mutational type the target aims to detect: Gene fusions, Small variants (single/di-nucleotide variants or small indels), Focal deletions of IKZF1/ERG, DUX4 expression (indicative of DUX4-rearrangement) or IGH rearrangements with CRLF2/EPOR.

The script run_km.sh requires as input the path to R1 and R2 fastq files for a sample, as well as an argument specifying the mutation type or set of targets to test against. This script will first use jellyfish to generate a k-mer count table (k=31b) from the raw fastq files. Secondly, a command is called to run output countTable31.jf against the specified set of targets.

1. To view the required arguments for run_km.sh:

```
bash run_km.sh

Usage: run_km.sh [FASTQ_R1] [FASTQ_R2] [TYPE]
Incorrect number of arguments
- Required: FASTQ_R1 = FASTQ PAIRED-END READ 1
- Required: FASTQ_R2 = FASTQ PAIRED-END READ 2
- Required: TYPE = Target type (SNV | Fusion | DUX4 | FocDel | IGH)
```

Fastq files should named with \_1.fastq.gz and \_2.fastq.gz extensions to represent read1 and read2 files. Full path to fastq location needs to be provided. 

2. In the example below fastq files are run against the SNV targets. Use the same command but specify full path to location of own fastq files.

```
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz SNV
```

This script generates a subdirectory within `km_ALL_targets` called `output` for output files. Within this k-mer count tables from jellyfish and text files generated by km for a given sample/targetType will be written into a sample directory labelled with basename of the fastq files.

```
ls output/testSampleA/
countTable31.jf  testSampleA_SNV.txt
```
3. Separate .txt files are generated with output from each of the targetTypes (SNV.txt, Fusion.txt, FocDel.txt, DUX4.txt and IGH.txt). These can be generated by altering the \[TYPE] argument as follows:

```
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz Fusion
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz FocDel
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz DUX4
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz IGH  # Note longer run time approx. 6 min for fastq files ~65M reads

ls output/testSampleA/
countTable31.jf  testSampleA_DUX4.txt  testSampleA_final_variants.csv  testSampleA_FocDel.txt  testSampleA_Fusion.txt  testSampleA_IGH.txt  testSampleA_SNV.txt
```

Producing the k-mer count table (countTable31.jf) is generally the rate limiting step of the process. The `run_km.sh` script therefore checks for the presence of the `countTable31.jf` first and if present does not re-generate this file but simply performs a `wc -l` command to read the data into memory.

The final target set 'IGH' contains the greatest number of targets given the highly variable nature of IGH-CRLF2 and IGH-EPOR rearrangements. Run times against this target set are therefore substantially longer ~6 mins vs a few seconds for testing other target types.

#### Collate results

The text file produced by km indicates results for all target sequences provided for a given mutation type. Many of these will be null results (no mutation identified). We have therefore written an R script that reads in these raw output files, filteres the output for identified fusions/variants and provides some additional annotation (e.g. AA.Change for a detected SNV). The script will then write to the same output dir a csv file containing idenified mutations of any type tested.

The R script requires the following libraries. If not already present the script will install these required packages the frist time it is run.

Install R libraries:
- tidyverse
- Biostrings
- here

4. To run on a single sample the script requires an argument specifying path to the output directory for the sample under analysis.

Usage: Rscript bin/filter_km_output.R `[path/to/outut/dir]`

```
Rscript bin/filter_km_output.R output/testSampleA/
```

The `final_variants.csv` file has the following headers. If no mutations of any type were identified then a csv file containing only the header row is produced.

```
cat output/testSampleA/testSampleA_final_variants.csv
"Target_Type","Alteration","Query","Type","Variant_name","rVAF","Expression","Min_coverage","Sequence","Reference_sequence"
```
Most of these fields are taken directly from the raw km output file while others are generated by the `filter_km_output.R` script. These fields indicate:

- Target_Type : Whether the mutation is a gene fusion (Fusion); single/di-nuclotide variant or indel (SNV); focal deletion (FocDel); DUX4 expression (DUX4); or IGH rearrangement (IGH) 
- Alteration : The annotated alteration.
      For a fusion the format is : gene1-gene2 identifed at the fusion break-point  e.g. BCR-ABL1 
      For an SNV/small variant  : gene AA.Change  e.g. CRLF2 F232C 
      For a focal deletion : gene exons-deleted e.g. IKZF1 4-7 del 
      For DUX4 expression : DUX4-rearrangement  (additional information given in other fields i.e. number of DUX4 targets (out of 9) detected & mean Min_coverage 
      For IGH : gene1-gene2 indentifed at/near potential breakpoint e.g. EPOR-IGHV4-39  
- Query : specific fasta file containing the target sequence for testing 
- Type : Type of mutation reported by km. If the target sequence is recreated (as in the case of fusions/DUX4) this will be 'Reference'. Otherwise can be 'Substitution', 'insertion', 'deletion', 'indel' or 'ITD' 
- Variant_name : Reported by km. Indicates sequence variation from the target sequence provided e.g. 35:t/G:36 to indicate t at base 35 of target sequence is substituted for G
- rVAF : Reported by km. Indicates ratio of coverage over reference path compared with alternate path representing a variant. For instances where expression of the reference target sequence is indicative of a mutation (e.g. fusions, DUX4 expression) this will be NA.
- Expression : Reported by km. 
- Min_coverage : Reported by km. Indicates the minimum number of k-mers covering any given position of the target sequence.
- Sequence : Reported by km. Is the sequence identified by overlapping k-mers beginning with the first 31b k-mer and ending with the final 31b k-mer of the target sequence.
- Reference_sequence : Reported by km. Is the sequence present in the target being queried.


## Run on multiple samples

ALL patients may posess a combination of genetic alterations of multiple types (SNVs, fusions, focal deletions) all contributing to disease. The overall aim of this package was to assess patients simultaneously for multiple mutation types, but limit the search for those variants which have been recurrently observed and are known to be clinically relevant. We therefore generally wish to assess multiple samples from a single sequencing run against all target sets. 

A helper script has been written for this purpose. This script requires a text file with locations of R1 and R2 for all samples to be tested. This script will perform run_km.sh on all samples for all target types and also collate results with the previously described R script. 

1. To view the required arguments for helper_script.sh:

```
bash helper_script.sh

Usage: helper_script.sh [SAMPLE_SHEET]
Incorrect number of arguments
- Required: SAMPLE_SHEET = Tab-delimited Text file containing FASTQ R1 and R2 locations

<READ1 PATH> <--TAB--> <READ2 PATH>

```
2. To run `helper_script.sh` modify the following command with path/file of your own sample_sheet:

```
cat sampleSheet.tsv 
/home/SAHMRI.INTERNAL/jacqueline.rehn/test_data/testSampleA_1.fastq.gz	/home/SAHMRI.INTERNAL/jacqueline.rehn/test_data/testSampleA_2.fastq.gz
/home/SAHMRI.INTERNAL/jacqueline.rehn/test_data/testSampleB_1.fastq.gz	/home/SAHMRI.INTERNAL/jacqueline.rehn/test_data/testSampleB_2.fastq.gz

bash helper_script.sh sampleSheet.tsv
```


## Notes

- There will be `PathQuant.py:125: RuntimeWarning: invalid value encountered in greater_equal` warnings on km but these can be ignored
- Summary Rscript requires `tidyverse`, `Biostrings` and `here` r packages and are installed at the start of the script. If there are any issues, it might be worth running on your local copy of R (rather than conda env).
