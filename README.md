
# `km` analysis with SAHMRI ALL targets

Jimmy Breen : jimmy.breen@sahrmi.com
Jacqueline Rehn : jacqueline.rehn@sahmri.com

Utilises k-mer variant detection software 'km' developed by a canadian bioinformatic group (https://github.com/iric-soft/km) and input targets designed for all gene fusions/variants

## Install jellyfish and km

1. To install and run the km script we'll need to create a conda environment to install km and jellyfish in. Jellyfish needs additional python bindings to work with km, so we have created an install procedure to follow.

```
conda create -n km python=3.7 virtualenv -y
conda activate km
```

2. Next we will clone the git repository containing the targets generated for detecting ALL specific fusions/variants as well as bash scripts to install and run km against these targets. 
```
git clone https://github.com/sagc-bioinformatics/km_ALL_targets.git
```

3. Now we can install the km/jellyfish components using this `install.sh` script. First we change into the km_ALL_targets directory generated by git, or an alternate directory for the git-repository if one was spcified. We then run the install script which will install km and jellyfish into this directory. The install script will also perform a test of km using test count-data and targets provided by the developers of km. Output from this test will be written to stout. Note the install script requires curl be installed on your machine. 

```
cd km_ALL_targets
bash install.sh
```

## Quick Start

4. We now wish to test km against a sample utilising the ALL_targets. ALL_targets have been subdivided according to the main mutational type the target aims to deted: Gene fusions, Small variants (single/di-nucleotide variants or small indels), Focal deletions of IKZF1/ERG, DUX4 expression (indicative of DUX4-rearrangement) or IGH rearrangements with CRLF2/EPOR.

The script run_km.sh requires as input the path to R1 and R2 fastq files for a sample, as well as an argument specifying the mutation type or set of targets to test against. This script will first use jellyfish to generate a k-mer count table (k=31b) from the raw fastq files. Secondly, a command is called to run output countTable31.jf against the specified set of targets.

To view the required arguments for run_km.sh:

```
bash run_km.sh

Usage: run_km.sh [FASTQ_R1] [FASTQ_R2] [TYPE]
Incorrect number of arguments
- Required: FASTQ_R1 = FASTQ PAIRED-END READ 1
- Required: FASTQ_R2 = FASTQ PAIRED-END READ 2
- Required: TYPE = Target type (SNV | Fusion | DUX4 | FocDel | IGH)
```

Fastq files should named with \_1.fastq.gz and \_2.fastq.gz extensions to represent read1 and read2 files. Full path to fastq location needs to be provided. In the example below fastq files are run against the SNV targets. The same command can be used but specify full path to location of own fastq files.

```
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz SNV
```

This script generates a subdirectory within `km_ALL_targets` called `output` for output files. Within this k-mer count tables from jellyfish and text files generated by km for a given sample/targetType will be written into a sample directory labelled with basename of the fastq files.

```
ls output/testSampleA/
countTable31.jf  testSampleA_SNV.txt
```
Separate .txt files are generated with output from each of the targetTypes (SNV.txt, Fusion.txt, FocDel.txt, DUX4.txt and IGH.txt). These can be generated by altering the \[TYPE] argument as follows:

```
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz Fusion
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz FocDel
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz DUX4
bash run_km.sh ~/test_data/testSampleA_1.fastq.gz ~/test_data/testSampleA_2.fastq.gz IGH  # Note longer run time approx. 6 min for fastq files ~65M reads
```
Producing the k-mer count table (countTable31.jf) is generally the rate limiting step of the process. the `run_km.sh` script therefore checks for the presence of the `countTable31.jf` first and if present does not re-generate this file but simply performs a `wc -l` command to read the data into memory and speed up process for km.

The final target set 'IGH' contains the greatest number of targets given the highly variable nature of IGH-CRLF2 and IGH-EPOR rearrangements. Run times against this target set are therefore substantially longer ~6 mins vs a few seconds for testing other target types.

## Collate results

The text file produced by km indicates results for all target sequences provided for a given mutation Type. Many of these will be null results (no mutation identified). We have therefore written an R script that reads in these raw output files, filteres the output for identified fusions and provides some additional annotation (e.g. AA.Change for a detected SNV). The script will then write to the same output dir a csv file containing idenified mutations of any type tested.

The R script requires the following libraries. If not already present the script will install these required packages the frist time it is run.

Install R libraries:
- tidyverse
- Biostrings
- here

To run on a single sample the script requires an argument specifying path to the output directory for the sample under analysis.

Usage: Rscript bin/filter_km_output.R `[path/to/outut/dir]`

```
Rscript bin/filter_km_output.R output/testSampleA/
```

## Run on multiple samples

ALL patients may posess a combination of genetic alterations of multiple types (SNVs, fusions, focal deletions) all contributing to disease. The overall aim of this package was to assess patients simultaneously for multiple mutation types, but limit the search for those variants which have been recurrently observed and are known to be clinically relevant. We therefore generally wish to assess multiple samples from a single sequencing run against all target sets. 

A helper script has been written for this purpose. This script requires a text file with locations of R1 and R2 for all samples to be tested. This script will perform run_km.sh on all samples for all target types and also collate results with the previously described R script. 

```


```


## Notes

- There will be `PathQuant.py:125: RuntimeWarning: invalid value encountered in greater_equal` warnings on km but these can be ignored
- Summary Rscript requires `tidyverse`, `Biostrings` and `here` r packages and are installed at the start of the script. If there are any issues, it might be worth running on your local copy of R (rather than conda env).
